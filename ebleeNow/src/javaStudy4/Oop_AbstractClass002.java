package javaStudy4;
/* 추상 클래스
 * 추상클래스는 다른 클래스들의 공통적인 특징을 변수나 메서드로 정의만 해놓는 것을 말한다. --> 추상메서드
 * abstract를 앞에 붙이고 클래스 안에 추상메서드를 포함하고 있다는 것을 제외하면 사실 일반 클래스와 별반 차이가 없다.
 * Field, Constructor, Method(일반메서드)도 포함할 수 있다.
 * 메서드 선언만 있고 구체적인 내용을 없으므로 객체를 생성할 수 없다.
 * 따라서 부모클래스로서의 역할은 하지만, 구체적인 사용은 상속받은 자식 클래스에서 재정의(오버라이딩)하여 사용해야한다. ->강제성
 * 추상 클래스에서 선언만 해놓음으로써 이후 새로운(자식) 클래스들이 이를 상속받아 구현하므로 새로운 클래스를 작성할 때 하나의 틀이 된다.
 * 
 * 왜 사용하니?
 * 부모(추상)클래스가 선언해놓은 메서드를 상속받은 자식 클래스들이 이름 그대로 재정의해서 구현하라고 강제하는 것이다.
 * 상속받은 자식 클래스 입장에서는 자칫 상속만 받고 재정의해서 사용을 안할 수도 있기 때문이다.
 * 즉, 일반메서드로 구현하면 누군가는 해당 메서드를 구현 안 할 수도 있다.
 * 모조건 상속받은 자식 클래스 입장에서는 추상메서드를 재정의해서 구현하도록 강제하기위함이다.
 * 
 * 반드시 재정의(override)해야하는가?
 * 그렇다.
 * 자식 클래스는 무조건 부모(추상)클래스로부터 상속받은 추상 메서드는 오버라이딩해서 재정의 해야한다.
 * 추상메서드를 포함하고 있다면 곧 추상 클래스여야한다.
 * 
 * 그렇게하고싶지않다면?
 * 자식도 추상크래스로 쓰면 됨
 * 
 * >>>>>결론
 * 부모(추상)클래스에서 구현을 하지 않는 이유는 해당 메서드의 구현이 상소받는 클래스에 따라서 달라질 수 있기때문에 선언만 해둔 것이다.
 * 이러한 추상클래스는 여러명의 개발자가 작업할 때 코드의 확장과 분업을 효율적으로 처리할 수 있게 해준다.
 * 분업화된 시스템에서 공통의 프로젝트를 진행할 때 많이 사용되어지는 문법이다.
 * */
abstract class Animala{
	//구체적인 내용은 작성하지 않고 공통적인 특징을 추상적으로 선언 -> 리턴값조차도 없이 메서드명만 선언
	abstract void cry();
}
class Animalb{
	void fly() {System.out.println("fly >>> ");}
}
class Dog2 extends Animala{
	void cry() {System.out.println("멍멍 ~~");}
}
class Cat2 extends Animala{
	void cry() {System.out.println("야옹야옹 ~~");} // cry()  메서드 지우면 에러 >> 추상메서드를 재정의(오버라이딩)하지 않아서.
}
public class Oop_AbstractClass002 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		//추상클래스는 구체적인 내용이 없기 때문에 객체를 생성할 수 없다.
		//Animal dog = new Animal();
		Animalb dragonfly = new Animalb();
		dragonfly.fly();
		
		//추상 크래스 사용은 ? >> 상속받아서 사용
		Dog2 dog = new Dog2();
		dog.cry();
		
		Cat2 cat = new Cat2();
		cat.cry();
		
		
	}//main

}//class
